<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редактор для сюжетных игр</title>
    <style>
        * {
            border: 0;
            margin: 0;
            box-sizing: border-box;
            z-index: 5;
            user-select: none;
            overscroll-behavior: none;
        }
        input:focus {
            user-select: all;
        }
        input[type=text] {
            font-size: 16px;
        }
        .scenario-block {
            display: flex;
            flex-direction: column;
            width: 180px;
            height: 100px;
            background: #ffffff1a;
            border: 2px solid #e4e4f6;
            margin: 10px;
            text-align: center;
            line-height: 100px;
            cursor: pointer;
            position: absolute;
            opacity: 0.8;
            border-style: dashed;
            border-radius: 8px;
            font-size: 16px;
        }
        .scenario-block:hover {
            border-style: ridge;
        }
        .scenario-block::selection {
            background-color: #eaeeff;
            color: black;
        }
        .custom-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        .custom-menu div {
            padding: 8px 12px;
            cursor: pointer;
        }
        .custom-menu div:hover {
            background: #ddd;
        }
        .sc-name {
            font-size: 16px;
            max-width: 90%;
            width: 90%;
            /* font-weight: bold; */
            font-style: italic;
            font-family: 'Arial Narrow';
            background: none;
            color: #c3f3ff;
            z-index: 60;
        }
        .ins {
            max-width: 100%;
            display: flex;
            margin-top: 5px;
            flex-direction: column;
            z-index: 60;
        }
        .input {
            height: 21px;
            background: none;
            font-family: monospace;
            max-width: 90%;
            white-space: normal;
            color: rgb(226 237 255);
            width: 90%;
        }
        .outs {
            max-width: 100%;
            display: flex;
            margin-top: 25px;
            flex-direction: column;
            z-index: 60;
        }
        .output {
            height: 21px;
            background: none;
            font-family: monospace;
            max-width: 90%;
            white-space: normal;
            color: rgb(195 149 149);
            width: 90%;
        }
        .output::placeholder {
            color: red;
            font-weight: bold;
        }
        .input::placeholder {
            color: red;
            font-weight: bold;
        }
        .input:placeholder-shown {
            border: 2px solid rgb(255, 0, 0);
        }
        .output:placeholder-shown {
            border: 2px solid rgb(255, 0, 0);
        }
        input:focus{
            outline: none;
        }
        #targetElement{
            position: fixed;
            z-index: 0;
            background-image: url('data:image/svg+xml,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="100" height="100" stroke="hsl(212, 90%, 35%)" stroke-width="1" fill="none"/><line x1="25" y1="0" x2="25" y2="100" stroke="hsl(212, 30%, 30%)" stroke-width="1"/><line x1="50" y1="0" x2="50" y2="100" stroke="hsl(212, 30%, 30%)" stroke-width="1"/><line x1="75" y1="0" x2="75" y2="100" stroke="hsl(212, 30%, 30%)" stroke-width="1"/><line x1="0" y1="25" x2="100" y2="25" stroke="hsl(212, 30%, 30%)" stroke-width="1"/><line x1="0" y1="50" x2="100" y2="50" stroke="hsl(212, 30%, 30%)" stroke-width="1"/><line x1="0" y1="75" x2="100" y2="75" stroke="hsl(212, 30%, 30%)" stroke-width="1"/></svg>'); 
            background-color: hsl(212, 90%, 10%);
            background-size: 100px;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
        }
        #scenario-content {
            min-width: 100vw;
            min-height: 100vh;
        }
        .output-div {
            display: flex;
            width: 170px;
        }
        .port {
            height: 21px;
            border-right: 11px dotted red;
        }
        .text-div {
            display: flex;
            flex-direction: column;
        }
        .text-speaker {
            font-weight: bold;
            width: 120px;
            background: none;
            font-size: 16px;
        }
        .text-speaker::selection {
            background-color: wheat; 
        }
        .text-input {
            width: 150px;
            background: none;
            border: none;
            font-size: 16px;
        }
        .dialogue {
            font-size: 16px;
            cursor: pointer;
            position: absolute;
            background: white;
            border-radius: 10px;
            box-shadow: 5px 5px 5px -5px rgba(34, 60, 80, 0.6);
            display: flex;
            flex-direction: column;
            padding: 5px;
            justify-content: space-between;
        }
        .editor-panel {
            position: fixed;
            top: 0;
            right: -100vw; /* Панель скрыта */
            width: 100vw;
            height: 100svh;
            max-width: 100vw;
            max-height: 100vh;
            background: #f0f0f0;
            transition: transform 0.3s ease-in-out;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            z-index: 70;
            overflow: scroll;
        }
        .editor-panel.open {
            transform: translateX(-100vw);
        }
        .hidden {
            pointer-events: none;
            opacity: 0;
        }
        .choice-input {
            width: 90%;
            font-family: monospace;
            font-size: 16px;
        }
        .port.choice-div {
            border-color: rgb(69, 61, 146);
        }
        #close-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            left: unset;
            z-index: 1000;
            position: fixed;
            background-color: #ff6e0073;
            border: 3px dotted #873e3e36;
            border-radius: 15px;
        }
        .setup {
            box-shadow: 6px 6px 14px 2px rgba(255, 255, 255, 0.3);
            opacity: 0.3;
            display: flex;
            z-index: 99;
            position: fixed;
            top: 0;
            border-radius: 0 0 5px 5px;
            overflow-x: hidden;
            transition: all .3s ease;
        }
        .setup:hover {
            box-shadow: none;
            opacity: 1;
        }
        .setup span {
            background: white;
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            width: 20px;
            text-align: center;
            height: 20px;
            border-radius: 0 0 5px 5px;
            line-height: 18px;
            transition: all .3s ease;
        }
        .setup span:hover {
            height: 25px;
            line-height: 25px;
        }
        #fileInput {
            display: none;
        }
        #fileInput2 {
            display: none;
        }
        .custom-file-label {
            display: inline-block;
            padding: 5px 10px;
            background-color: #5c66f3;
            color: white;
            cursor: pointer;
            border-radius: 0 0 5px 5px;
            font-family: sans-serif;
            font-size: 14px;
            text-align: center;
            width: 120px;
        }
        .alert-container {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 300px;
            z-index: 9999;
        }
        .alert {
            background-color: #f0f0f0;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: sans-serif;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .show {
            opacity: 1;
            transform: translateY(0);
        }
        .alert .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background-color: #3498db;
            width: 100%;
            transition: width linear;
        }
        /* ----------------------------------------------------------- */
        .usual { color: #333; }
        .warning { color: #d35400; }
        .error { color: #c0392b; }
        .attention { color: #8e44ad; }
        /* ----------------------------------------------------------- */
        .usual .progress-bar { background-color: #333; }
        .warning .progress-bar { background-color: #d35400; }
        .error .progress-bar { background-color: #c0392b; }
        .attention .progress-bar { background-color: #8e44ad; }
        /* ----------------------------------------------------------- */
        .setupable {
            width: 170px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 30px;
            align-items: center;
            z-index: 10;
        }
        .freezed {
            width: 180px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            min-height: 100svh;
        }
        .input-block {
            width: 170px;
            padding: 5px;
            overflow: hidden;
            background-color: #5c66f3;
            /* border: 2px solid #444444; */
            box-shadow: 8px 8px 5px -5px rgba(0, 0, 0, 0.26);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 10px;
            opacity: 0.9;
        }
        .ispan {
            width: 245px;
            height: 42px;
            padding: 0;
            font-size: 16px;
            font-family: monospace;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            color: white
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 270px;
            height: 6px;
            background: #e0e0e0;
            border-radius: 10px;
            outline: none;
            margin-left: 3px;
            cursor: pointer;
            box-sizing: content-box;
            border: 2px solid black;
        }

        /* Цветовая дифференциация — например, по ID */
        #gi {
            background: linear-gradient(to right, #4CAF50, #a5d6a7);
        }
        #mti {
            background: linear-gradient(to right, #2196F3, #90caf9);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #d4d4d4;
        }
        .input-block .port {
            border-color: white;
        }

        .operator {
            font-size: 16px;
            cursor: pointer;
            position: absolute;
            background: #d1d1d1;
            border-radius: 10px;
            box-shadow: 8px 8px 5px -5px rgb(0 0 0 / 42%);
            display: flex;
            padding: 15px;
            justify-content: space-between;
            width: 185px;
            z-index: 9;
            align-items: center;
        }
        .op-content {
            display: flex;
            flex-direction: column;
            width: 150px;
        }
        .op-priority {
            background: none;
            font-size: 16px;
            font-weight: bold;
            /* color: #ffffff78; */
            color: #757575;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
        }
        .op-name {
            background: none;
            font-size: 16px;
            color: white;
        }
        .port.op-next {
           border-color: #453d9254;
        }
        .symbiote {
            position: absolute;
            display: flex;
            height: 20px;
            opacity: 0.85;
            pointer-events: none;
        }
        .sym-decoration {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff8080;
            margin-right: 4px;
            position: absolute;
            top: 0px;
            left: -10px;
        }
        .sym-textfield {
            background: #ff8080;
            padding-right: 5px;
            font-family: monospace;
            line-height: 20px;
            border-radius: 0 2px 2px 0;
            font-style: italic;
            padding-left: 11px;
            font-weight: bold;
            font-size: 13px;
            overflow-y: hidden;
        }
        .scenario-block.imported {
            border: none;
        }
    </style>
</head>
<body style="z-index: -999999;overflow: scroll;">
    <div class="setup left" style="width: 20px;left: calc(50vw - 90px);">
        <span title="import" onclick="document.getElementById('fileInput2').click()">+</span>
        <input type="file" id="fileInput2" accept=".json" onchange="Import()">
    </div>
    <div class="setup" style="width: 120px;left: calc(50vw - 70px);">
        <label title="remove all and import" for="fileInput" class="custom-file-label">открыть файл</label>
        <input type="file" id="fileInput" accept=".json" onchange="loadJSON()">
    </div>
    <div id="targetElement" oncontextmenu="scenarioContextMenu(event)" ondblclick="scenarioContextMenu(event)"></div>
    <div id="scenario-content"></div>
    <button onclick="closeEditor()" class="hidden" id="close-btn">Закрыть и сохранить</button>
    <div id="dialogueEditor" class="editor-panel" oncontextmenu="dialogueContextMenu(event)" ondblclick="dialogueContextMenu(event)">
        <div class="editor-content" id="dialogue-content">
            <!-- Контент редактора -->
        </div>
    </div>

    <div class="alert-container">
        <div class="alert" id="alert-box" style="display: none;">
            <span id="alert-text"></span>
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>

    <div id="menu" class="custom-menu"></div>
<script>
    let scenario_blocks = []
    let current_quest = null
    let global_data = []
    const DW = document.querySelector("#dialogue-content")
    const MW = document.querySelector("#scenario-content")
    let dialogue_nodes = []
    let wireConnections = []
    let dialogueWires = []
    let input_nodes = []
    let operator_nodes = []
    let symbiotes = []

    let timer = null
    let windowChoice, windowOpened = null

    class ScenarioBlock {
        constructor(data, index) {
            this.data = data;
            this.index = index;
            this.name = data.name;
            this.inputs = data.inputs;
            this.outputs = data.outputs;
            this.pos = data.pos ? data.pos : [0, 0]
            this.element = document.createElement("div");
            this.element.classList.add("scenario-block");

            this.name_i = document.createElement("input");
            this.name_i.value = this.name
            this.name_i.classList.add("sc-name")
            this.element.appendChild(this.name_i)

            this.ins = document.createElement("div")
            this.ins.classList.add("ins")
            this.updateInputs()

            this.outs = document.createElement("div")
            this.outs.classList.add("outs")
            this.updateOutputs()
            
            const hr = document.createElement("hr")
            hr.style = "border-style: inset; border-width: 1px"
            this.element.appendChild(hr)
            this.element.appendChild(this.ins);
            this.element.appendChild(this.outs);
            
            this.element.style.left = `${Math.max(0, this.pos[0])}px`
            this.element.style.top = `${Math.max(0, this.pos[1])}px`

            MW.appendChild(this.element);
            this.addEventListeners();
            this.addDragEvents();
            this.updateHeight();
        }

        updateHeight() {
            let ch = (21 * this.inputs.length + 5) + (21 * this.outputs.length + 25) + 25
            this.element.style.height = `${ch}px`
            spawnWires()
        }

        updateInputs() {
            this.ins.innerHTML = ""
            this.inputs.forEach((input, index) => {
                const inp = document.createElement("input");
                inp.value = input.name ? input.name : "new_input"
                inp.classList.add("input")
                inp.dataset.last = 49
                inp.placeholder = '"enter" to remove'
                inp.addEventListener("input", () => { if (inp.value.length >= 50 && inp.dataset.last < inp.value.length) Alert("Please, try to made it shorter. Reformulate a clear condition or split it on the parts if its possible. It`ll be good for your coder mental health", "attention"); inp.dataset.last = Math.max(inp.value.length, 49); if (inp.value.length < 6) Alert("Describe it better! At least a simple sentence like 'I ate'", "error") })
                inp.addEventListener("change", () => { if (inp.value.length < 1) { this.inputs.splice(index, 1); this.updateInputs()}})
                this.ins.appendChild(inp)
            })
            this.updateHeight();
        }
        
        updateOutputs() {
            this.outs.innerHTML = ""
            this.outputs.forEach((output, index) => {
                const outDiv = document.createElement("span")
                outDiv.classList.add("output-div", "port")
                const outp = document.createElement("input");
                outp.value = output.name ? output.name : `new_output`
                outp.dataset.next = output.next ? output.next : null
                outp.classList.add("output")
                outp.placeholder = '"enter" to remove'
                outp.addEventListener("change", () => { if (outp.value.length < 1) { this.outputs.splice(index, 1); this.updateOutputs()}})
                outDiv.appendChild(outp)
                this.outs.appendChild(outDiv)
            })
            this.updateHeight();
        }

        addDragEvents() {
            let offsetX, offsetY, isDragging = false;

            this.element.addEventListener("mousedown", (event) => {
                if (this.element.classList.contains("imported")) {
                    this.element.classList.remove("imported");
                }
                isDragging = true;
                if (event.target.classList.contains("port")) { isDragging = false }
                offsetX = event.clientX - this.element.offsetLeft;
                offsetY = event.clientY - this.element.offsetTop;
            });

            document.addEventListener("mousemove", (event) => {
                if (!isDragging) return;
                const newX = event.clientX - offsetX;
                const newY = event.clientY - offsetY

                this.element.style.left = `${Math.max(0, newX)}px`;
                this.element.style.top = `${Math.max(0, newY)}px`;

                this.outs.querySelectorAll(".port").forEach((output) => {
                    wireConnections.forEach(wire => {
                        if (wire.startElement === output || wire.endElement === this.element) {
                            wire.updatePosition(event);
                        }
                    });
                })
                if (this.outs.querySelectorAll(".port").length == 0) {
                    wireConnections.forEach(wire => {
                        if (wire.endElement === this.element) {
                            wire.updatePosition(event);
                        }
                    });
                }
            });

            document.addEventListener("mouseup", () => {
                isDragging = false;
            });
        }

        addEventListeners() {
            this.element.addEventListener("dblclick", (event) => {
                openEditor(this.getData());
            })
            this.element.addEventListener('contextmenu', (event) => { 
                event.preventDefault()
                showMenu(["add input", "add output", "edit dialogue lines", "remove~"], event, (callback) => {
                    if (callback == "edit dialogue lines") openEditor(this.data);
                    if (callback == "add input") { this.inputs.push({ name: "new_input", state: "false" }); this.updateInputs() }
                    if (callback == "add output") { this.outputs.push({ name: "new_output", next: null }); this.updateOutputs() }
                    if (callback == "remove~") { this.element.remove(); delete global_data[this.index]; delete scenario_blocks[this.index]; spawnWires() }
                })
            })
        }
        
        getElement() {
            return this.element; // Возвращаем DOM-элемент
        }

        getData() {
            let inputs = []
            this.ins.childNodes.forEach((input) => {
                const new_dict = {}
                new_dict["name"] = input.value
                new_dict["state"] = false
                inputs.push(new_dict)
            })
            let outputs = []
            this.outs.childNodes.forEach((output) => {
                const new_dict = {}
                new_dict["name"] = output.querySelector(".output").value
                new_dict["next"] = output.querySelector(".output").dataset.next
                outputs.push(new_dict)
            })
            return {
                "inputs": inputs,
                "outputs": outputs,
                "name": this.name_i.value,
                "pos": [this.element.offsetLeft, this.element.offsetTop],
                "operators": global_data[this.index]?.operators ?? [], // проверяем что запись вообще есть в global_data и проверяем наличие ключа .operators в ней
                "dialogues": global_data[this.index]?.dialogues ?? [],
                "index": this.index
            }
        }
    }
    
    class DialogueBlock {
        constructor (data) {
            this.id = data.id
            this.text = data.text
            this.speaker = data.speaker
            this.pos = data.pos
            this.choices = data.choices ? data.choices : [] 
            this.height = 50
            this.element = document.createElement('div')
            this.element.classList.add("dialogue")

            // ---------------------text------------------------- //
            this.textDiv = document.createElement("div")
            this.textDiv.classList.add("text-div")

            this.texti = document.createElement("textarea")
            this.texti.style.resize = "none"
            this.texti.classList.add("text-input")
            this.texti.value = this.text
            this.texti.addEventListener("input", () => { this.text = this.texti.value; this.resize(); })

            this.speakeri = document.createElement("input")
            this.speakeri.classList.add("text-speaker")
            this.speakeri.value = this.speaker
            this.speakeri.addEventListener("input", () => { this.speaker = this.speakeri.value })

            this.textDiv.appendChild(this.speakeri)
            this.textDiv.appendChild(this.texti)
            // --------------------------------------------------- //

            this.element.appendChild(this.textDiv)

            // -----------------------choices--------------------- //
            this.choicesDiv = document.createElement("div")
            this.choicesDiv.classList.add("choices-div")

            this.updateChoices();
            // --------------------------------------------------- //
            
            this.element.style.left = `${this.pos[0]}px`;
            this.element.style.top = `${this.pos[1]}px`;
            this.element.appendChild(this.choicesDiv)
            DW.appendChild(this.element)
            this.resize()
            this.addDragEvents()
            this.addEventListeners()

            if (data.speaker == "NPC") this.speakeri.focus()
            if (data.text == "") this.texti.focus()
        }

        resize() {
            this.texti.style.height = `0`; 
            this.texti.style.height = `${this.texti.scrollHeight}px`;

            this.height = 50
            this.height += this.textDiv.offsetHeight
            this.height += this.choicesDiv.offsetHeight
            this.element.style.height = `${this.height}px`
        }

        updateChoices() {
            this.choicesDiv.innerHTML = ""
            this.choices.forEach((choice, index) => {
                const choiceDiv = document.createElement("div")
                choiceDiv.classList.add("choice-div", "port")

                const choicei = document.createElement("input") 
                choicei.value = choice.short
                choicei.placeholder = '"enter" to remove'
                choicei.dataset.next = choice.next
                choicei.dataset.index = this.choices.indexOf(choice)
                choicei.classList.add("choice-input")
                choicei.addEventListener("input", () => { this.choices[choicei.dataset.index].short = choicei.value })
                choicei.addEventListener("change", () => { if (choicei.value.length < 1) { if (this.choices.length > 1) { this.choices.splice(index, 1); this.updateChoices()} else {Alert("You cant remove all choices, node become usefull")}}})

                choiceDiv.appendChild(choicei)
                choiceDiv.addEventListener("contextmenu", (event) => {
                    event.preventDefault(); event.stopPropagation();
                    choicei.style.color = "rgb(0, 0, 0, 0.4)"
                    setTimeout(() => {choicei.style.color = "revert-layer"}, 400)
                    showMenu(["choose ending"], event, (callback) => {
                            if (callback == "choose ending") { chooseEnding((userChoice) => { choicei.dataset.next = userChoice; this.choices[index].next = userChoice; respawnSymbiotes(); spawnDialogueWires()})}; 
                        }
                    );
                })
                choiceDiv.addEventListener("dblclick", (event) => {
                    event.preventDefault(); event.stopPropagation();
                    if (event.clientX > this.pos[0] + 180) {
                        choicei.style.color = "rgb(0, 0, 0, 0.4)"
                        setTimeout(() => {choicei.style.color = "revert-layer"}, 400)
                        chooseEnding((userChoice) => { choicei.dataset.next = userChoice; this.choices[index].next = userChoice; respawnSymbiotes(); spawnDialogueWires()})
                        // showMenu(["choose ending"], event, (callback) => {
                        //         if (callback == "choose ending") { chooseEnding((userChoice) => { choicei.dataset.next = userChoice; this.choices[index].next = userChoice; respawnSymbiotes(); spawnDialogueWires()})}; 
                        //     }
                        // );
                    }
                })

                this.choicesDiv.appendChild(choiceDiv)
            })
            this.resize();
            spawnDialogueWires();
            respawnSymbiotes();
        }

        getElement() {
            return this.element
        }

        addEventListeners() {
            this.element.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                event.stopPropagation(); // ивент не дойдет до родительского блока
                showMenu(["add choice", "remove node"], event, callback => {
                    if (callback == "remove node") { dialogue_nodes.pop(this.element); this.element.remove(); spawnDialogueWires(); respawnSymbiotes(); } 
                    if (callback == "add choice") { this.choices.push({"short": "new choice", "next": null}); this.updateChoices() }
                })
            })
            this.element.addEventListener("dblclick", (event) => {
                event.stopPropagation(); event.preventDefault();
                if (event.clientX > this.pos[0] + 120 && event.clientY < this.pos[1] + 20){
                    const new_dialogue = new DialogueBlock({"speaker": this.speaker, "text": "", "id": `node-${dialogue_nodes.length}`, "choices": [], "pos": [this.pos[0] + 250, this.pos[1]]}) 
                    global_data[current_quest].dialogues.push(new_dialogue.getData())
                    dialogue_nodes.push(new_dialogue)
                    Alert("Node speaker succesfully dublicated!")
                } else if (event.clientY > this.pos[1] + this.textDiv.offsetHeight + 12 && event.clientY < this.pos[1] + this.textDiv.offsetHeight + 50){
                    this.choices.push({"short": "new choice", "next": null}); this.updateChoices()
                } 
            })
        }

        addDragEvents() {
            let offsetX, offsetY, isDragging = false;
            this.element.addEventListener("mousedown", (event) => {
                isDragging = true;
                
                if (event.target.classList.contains("port")) { isDragging = false }
                offsetX = event.clientX - this.element.offsetLeft;
                offsetY = event.clientY - this.element.offsetTop;
            });

            document.addEventListener("mousemove", (event) => {
                if (!isDragging) return;
                
                let newLeft = Math.max(event.clientX - offsetX, 5);
                let newTop = Math.max(event.clientY - offsetY, 5);
                
                this.element.style.left = newLeft+ "px";
                this.element.style.top = newTop + "px";
                this.pos = [newLeft, newTop]
                
                if (this.choicesDiv.querySelector(".choice-div") !== null) {
                    this.choicesDiv.querySelectorAll(".choice-div").forEach((choice) => {
                        dialogueWires.forEach(wire => {
                            if (wire.startElement == choice || wire.endElement == this.element) {
                                wire.updatePosition(event);
                            }
                        });
                        symbiotes.forEach(sm => {
                            if (sm.portElement == choice) sm.updatePosition()
                        })
                    })
                } else {
                    dialogueWires.forEach(wire => {
                        if (wire.endElement == this.element) {
                            wire.updatePosition(event);
                        }
                    });
                }
            });

            document.addEventListener("mouseup", () => {
                isDragging = false;
            });
        }

        getData(){
            return {
                'id': this.id,
                'speaker': this.speaker,
                'text': this.text,
                'pos': this.pos,
                'choices': this.choices
            }
        }
    }

    class InputBlock {
        constructor (data) {
            this.name = data.name
            this.index = data.index
            this.element = document.createElement('div')
            this.element.classList.add("input-block")
            this.element.dataset.name = this.name
            this.element.dataset.index = this.index
            this.element.position = "absolute"
            this.element.zIndex = 2000

            this.textSpan = document.createElement("span")
            this.textSpan.classList.add("ispan")
            this.textSpan.textContent = this.name
            this.element.appendChild(this.textSpan)

            this.portDiv = document.createElement("div")
            this.portDiv.classList.add("port")
            this.element.appendChild(this.portDiv)

            this.element.addEventListener("mousedown", (event) => {
                // добавим особый проводок 
                new WireD(this.element)
            });

            document.querySelector(".setupable").appendChild(this.element)
        }

        getElement() {
            return this.element
        }

        getPos(){
            return [this.element.offsetX, this.element.offsetY]
        }
    }

    class OperatorBlock {
        constructor (data) {
            this.name = data.name || `new_operator_${document.querySelectorAll(".operator").length}`
            this.next = data.next || null
            this.connectedTo = data.connectedTo || []
            this.priority = data.priority || ""
            this.pos = data.pos
            this.element = document.createElement('div')
            this.element.classList.add("operator")

            this.content = document.createElement("div")
            this.content.classList.add("op-content")

            this.namei = document.createElement("input")
            this.namei.value = this.name || `new_operator_${document.querySelectorAll(".operator").length}`
            this.namei.classList.add("op-name")
            this.content.appendChild(this.namei)

            this.pi = document.createElement("input")
            this.pi.type = "number"
            this.pi.placeholder = "priority"
            this.pi.value = this.priority
            this.pi.classList.add("op-priority")
            this.pi.addEventListener('keypress', function(e) {if (!/[0-9]/.test(e.key)) { e.preventDefault(); Alert("Only numbers allowed!", "error")}});
            this.content.appendChild(this.pi)

            this.portDiv = document.createElement("div")
            this.portDiv.classList.add("op-fake")

            this.port = document.createElement("div")
            this.port.classList.add("port", "op-next")
            this.port.dataset.next = this.next
            this.portDiv.appendChild(this.port)
            
            this.element.style.left = `${this.pos[0]}px`;
            this.element.style.top = `${this.pos[1]}px`;
            this.element.appendChild(this.content)
            this.element.appendChild(this.portDiv)
            DW.appendChild(this.element)
            this.addDragEvents()
            this.addEventListeners()

            this.pi.focus()
        }

        getElement() {
            return this.element
        }

        addEventListeners() {
            this.element.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                event.stopPropagation(); // ивент не дойдет до родительского блока
                showMenu(["remove node"], event, callback => {
                    if (callback == "remove node") { operator_nodes.pop(this.element); this.element.remove(); spawnDialogueWires() } 
                })
            })
        }

        addDragEvents() {
            let offsetX, offsetY, isDragging = false;
            this.element.addEventListener("mousedown", (event) => {
                isDragging = true;
                
                if (event.target.classList.contains("port")) { isDragging = false }
                offsetX = event.clientX - this.element.offsetLeft;
                offsetY = event.clientY - this.element.offsetTop;
            });

            document.addEventListener("mousemove", (event) => {
                if (!isDragging) return;
                
                let newLeft = Math.max(event.clientX - offsetX, 5);
                let newTop = Math.max(event.clientY - offsetY, 5);
                
                this.element.style.left = newLeft+ "px";
                this.element.style.top = newTop + "px";
                this.pos = [newLeft, newTop]
                
                dialogueWires.forEach((wire) => {
                    if (wire.startElement == this.port) {
                        wire.updatePosition(event)
                    }
                    this.connectedTo.forEach(index => {
                        if (wire.startElement == input_nodes[index].portDiv) {   
                            wire.updatePosition(event)
                        }
                    })
                })
            });

            document.addEventListener("mouseup", () => {
                isDragging = false;
            });
        }

        getData(){
            return {
                'name': this.namei.value,
                'priority': this.pi.value,
                'next': this.port.dataset.next,
                'connectedTo': this.connectedTo,
                'active': false,
                'pos': this.pos
            }
        }
    }

    class Symbiote {
        constructor(data, index, portElement) {
            this.name = data.name
            this.nextQuest = data.next == "null"? "quest doesn`t choosen" : scenario_blocks[data.next].getData().name
            this.index = index
            this.id = `out_${this.index}`
            this.portElement = portElement
            this.element = document.createElement("div")
            this.element.classList.add("symbiote")

            this.decoration = document.createElement("div")
            this.decoration.classList.add("sym-decoration")

            this.textField = document.createElement("div")
            this.textField.classList.add("sym-textfield")

            this.text = document.createElement("p")
            this.text.classList.add("sym-text")
            this.text.textContent = this.nextQuest
            this.textField.appendChild(this.text)

            this.element.appendChild(this.decoration)
            this.element.appendChild(this.textField)
            if (portElement) DW.appendChild(this.element)
        }

        updatePosition() {
            const rect = this.portElement.getBoundingClientRect()
            const x = rect.left + rect.width - 5 
            const y = rect.top + rect.height / 2 - 16 
            this.element.style.left = `${x}px`
            this.element.style.top = `${y}px`
        }

        removeSelf() {
            this.element.remove();
            symbiotes.splice(this.index, 1);
        }
    }

    MW.addEventListener("mousedown", (event) => {
        if (event.target.classList.contains("port") && event.target.parentElement.parentElement.classList.contains("scenario-block")) { 
            const wire = new Wire(event.target);
            wireConnections.push(wire)
        }
    });

    class Wire {
        constructor(startElement, endElement=null) {
            this.startElement = startElement;
            this.endElement = endElement;

            this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.svg.style.position = "fixed";
            this.svg.style.width = "100%";
            this.svg.style.height = "100%";
            this.svg.style.zIndex = "50";
            this.svg.style.top = "0"
            this.svg.style.pointerEvents = "none";
            this.svg.classList.add("svg")
            MW.appendChild(this.svg);

            this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            this.path.setAttribute("stroke", "red");
            this.path.setAttribute("stroke-width", "2");
            this.path.setAttribute("fill", "none");
            this.svg.appendChild(this.path);

            this.startPos = this.getCenterPos(this.startElement, 1)//[this.getCenterPos(this.startElement)[0] + 50, this.getCenterPos(this.startElement)[1]];
            this.endPos = endElement == null ? { ...this.startPos } : this.getCenterPos(this.endElement, 2)
            
            this.boundUpdatePosition = this.updatePosition.bind(this);
            this.boundReleaseWire = this.releaseWire.bind(this);

            if (endElement == null) {
                document.addEventListener("mousemove", this.boundUpdatePosition);
                document.addEventListener("mouseup", this.boundReleaseWire);
            }
        }

        getCenterPos(element, change=0) {
            let rect = element.getBoundingClientRect();
            if (change == 1) return { x: rect.left + rect.width - 5, y: rect.top + rect.height / 2 - 4 };
            if (change == 2) return { x: rect.left, y: rect.top + rect.height / 2 };
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        updatePosition(event) {
            if (this.startElement) {
                this.startPos = this.getCenterPos(this.startElement, 1); // 🔥 Обновляем стартовую позицию
            }
            if (!this.endElement) {
                this.endPos = { x: event.clientX, y: event.clientY };
            } else {
                this.endPos = this.getCenterPos(this.endElement, 2);
            }
            this.updatePath();
        }

        updatePath() {
            let { x: x1, y: y1 } = this.startPos;
            let { x: x2, y: y2 } = this.endPos;
            let ctrl1 = { x: x1 + 50, y: y1 };
            let ctrl2 = { x: x2 - 50, y: y2 };
            this.path.setAttribute("d", `M ${x1},${y1} C ${ctrl1.x},${ctrl1.y} ${ctrl2.x},${ctrl2.y} ${x2},${y2}`);
        }

        releaseWire() {
            document.removeEventListener("mousemove", this.boundUpdatePosition);
            document.removeEventListener("mouseup", this.boundReleaseWire);

            if (this.endElement || !this.startElement) {
                return; 
            }

            let targetElement = this.findNearestPort();
            if (targetElement && targetElement !== this.startElement.parentElement.parentElement) {
                this.endElement = targetElement;
                this.endPos = this.getCenterPos(targetElement);

                this.editNext();
                this.updatePosition();
            } else {
                this.removeSelf();
            }
        }

        editNext() {
            let equal_element = null
            scenario_blocks.forEach((sc) => {
                if (sc.getElement() == this.endElement && equal_element === null) equal_element = sc
            })
            if (this.startElement.querySelector("input").dataset.next !== "null") {
                wireConnections.forEach((conn) => {
                    if (conn.startElement == this.startElement && conn.endElement !== this.endElement) conn.removeSelf()
                })
            }
            let index = 0
            this.startElement.parentElement.querySelectorAll(".output-div").forEach((el, i) => { if (el == this.startElement) index = i; })
            this.startElement.querySelector("input").dataset.next = equal_element.getData().index
            scenario_blocks.forEach((sc) => {
                let instance = null
                if (this.startElement.parentElement.parentElement == sc.getElement()) { instance = sc }
                if (instance !== null) {
                    instance.outputs[index].next = equal_element.getData().index
                }
            })
        }

        removeSelf () {
            this.svg.remove();
            wireConnections = wireConnections.filter(wire => wire !== this);
        }

        findNearestPort() {
            let ports = Array.from(document.querySelectorAll(".scenario-block"))
            // ports.push(...Array.from(document.querySelectorAll(".dialogue")))
            let closestPort = null;
            let minDist = 90;

            ports.forEach(port => {
                let portPos = this.getCenterPos(port);
                let dist = Math.hypot(portPos.x - this.endPos.x, portPos.y - this.endPos.y);
                if (dist < minDist) {
                    closestPort = port;
                    minDist = dist;
                }
            });
            return closestPort;
        }
    }

    DW.addEventListener("mousedown", (event) => {
        event.stopPropagation();

        if (!event.target.classList.contains("port")) return;

        const parent = event.target.closest(".dialogue, .operator, .input-block");
        if (!parent) return;

        let wire = null;

        if (parent.classList.contains("dialogue")) {
            wire = new WireD(event.target);
        } else if (parent.classList.contains("operator")) {
            wire = new WireO(event.target);
        } else if (parent.classList.contains("input-block")) {
            wire = new WireI(event.target);
        }

        if (wire) {
            dialogueWires.push(wire);
        }
    });


    class WireD {
        constructor(startElement, endElement=null) {
            this.startElement = startElement;
            this.endElement = endElement;

            this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.svg.style.position = "fixed";
            this.svg.style.width = "100%";
            this.svg.style.height = "100%";
            this.svg.style.zIndex = "100";
            this.svg.style.top = "0"
            this.svg.style.pointerEvents = "none";
            this.svg.classList.add("Dsvg")
            document.body.appendChild(this.svg);

            this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            this.path.setAttribute("stroke", "rgb(69, 61, 146)"); 
            this.path.setAttribute("stroke-width", "2");
            this.path.setAttribute("fill", "none");
            this.svg.appendChild(this.path);

            this.startPos = this.getCenterPos(this.startElement, 1)//[this.getCenterPos(this.startElement)[0] + 50, this.getCenterPos(this.startElement)[1]];
            this.endPos = endElement == null ? { ...this.startPos } : this.getCenterPos(this.endElement, 2)
            
            this.boundUpdatePosition = this.updatePosition.bind(this);
            this.boundReleaseWire = this.releaseWire.bind(this);

            if (endElement == null) {
                document.addEventListener("mousemove", this.boundUpdatePosition);
                document.addEventListener("mouseup", this.boundReleaseWire);
            }

            // bugfix
            if (!startElement.parentElement.parentElement.classList.contains("dialogue")) {
                document.removeEventListener("mousemove", this.boundUpdatePosition);
                document.removeEventListener("mouseup", this.boundReleaseWire);
                this.removeSelf()
            }
        }

        getCenterPos(element, change=0) {
            let rect = element.getBoundingClientRect();
            if (change == 1) return { x: rect.left + rect.width - 5, y: rect.top + rect.height / 2 - 4 };
            if (change == 2) return { x: rect.left, y: rect.top + rect.height / 2 };
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        updatePosition(event) {
            if (this.startElement) {
                this.startPos = this.getCenterPos(this.startElement, 1); // 🔥 Обновляем стартовую позицию
            }
            if (!this.endElement) {
                this.endPos = { x: event.clientX, y: event.clientY };
            } else {
                this.endPos = this.getCenterPos(this.endElement, 2);
            }
            this.updatePath();
        }

        updatePath() {
            let { x: x1, y: y1 } = this.startPos;
            let { x: x2, y: y2 } = this.endPos;
            let ctrl1 = { x: x1 + 50, y: y1 };
            let ctrl2 = { x: x2 - 50, y: y2 };
            this.path.setAttribute("d", `M ${x1},${y1} C ${ctrl1.x},${ctrl1.y} ${ctrl2.x},${ctrl2.y} ${x2},${y2}`);
        }

        releaseWire() {
            document.removeEventListener("mousemove", this.boundUpdatePosition);
            document.removeEventListener("mouseup", this.boundReleaseWire);

            if (this.endElement || !this.startElement) {
                return; 
            }

            let targetElement = this.findNearestPort();
            if (targetElement && targetElement !== this.startElement.parentElement.parentElement) {
                this.endElement = targetElement;
                this.endPos = this.getCenterPos(targetElement);

                this.editNext();
                this.updatePosition();

                respawnSymbiotes();
            } else {
                this.removeSelf();
            }
        }

        editNext() {
            try {
                let equal_element = null
                dialogue_nodes.forEach((dia) => {
                    if (dia.getElement() == this.endElement && equal_element === null) equal_element = dia
                })
                if (this.startElement.querySelector("input").dataset.next !== "null") {
                    dialogueWires.forEach((conn) => {
                        if (conn.startElement == this.startElement && conn.endElement !== this.endElement) conn.removeSelf()
                    })
                }
                let index = 0
                this.startElement.parentElement.querySelectorAll(".choice-div").forEach((el, i) => { if (el == this.startElement) index = i; })
                this.startElement.querySelector("input").dataset.next = equal_element.getData().id
                dialogue_nodes.forEach((dia) => {
                    let instance = null
                    if (this.startElement.parentElement.parentElement == dia.getElement()) { instance = dia }
                    if (instance !== null) {
                        instance.choices[index].next = equal_element.getData().id
                    }
                })
            } catch {
                console.log("[ERROR] Error is not fatal, don`t deserving any attention~ ")
            }
        }

        removeSelf () {
            this.svg.remove();
            dialogueWires = dialogueWires.filter(wire => wire !== this);
        }

        findNearestPort() {
            let ports = Array.from(document.querySelectorAll(".dialogue"))
            let closestPort = null;
            let minDist = 90;

            ports.forEach(port => {
                let portPos = this.getCenterPos(port);
                let dist = Math.hypot(portPos.x - this.endPos.x, portPos.y - this.endPos.y);
                if (dist < minDist) {
                    closestPort = port;
                    minDist = dist;
                }
            });
            return closestPort;
        }
    }

    class WireO {
        constructor(startElement, endElement=null) {
            this.startElement = startElement;
            this.endElement = endElement;

            this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.svg.style.position = "fixed";
            this.svg.style.width = "100%";
            this.svg.style.height = "100%";
            this.svg.style.zIndex = "100";
            this.svg.style.top = "0"
            this.svg.style.pointerEvents = "none";
            this.svg.classList.add("Dsvg")
            document.body.appendChild(this.svg);

            this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            this.path.setAttribute("stroke", "#a3a0bc"); 
            this.path.setAttribute("stroke-width", "2");
            this.path.setAttribute("fill", "none");
            this.svg.appendChild(this.path);

            this.startPos = this.getCenterPos(this.startElement, 1)//[this.getCenterPos(this.startElement)[0] + 50, this.getCenterPos(this.startElement)[1]];
            this.endPos = endElement == null ? { ...this.startPos } : this.getCenterPos(this.endElement, 2)
            
            this.boundUpdatePosition = this.updatePosition.bind(this);
            this.boundReleaseWire = this.releaseWire.bind(this);

            if (endElement == null) {
                document.addEventListener("mousemove", this.boundUpdatePosition);
                document.addEventListener("mouseup", this.boundReleaseWire);
            }

            // bugfix
            if (!startElement.parentElement.parentElement.classList.contains("operator")) {
                document.removeEventListener("mousemove", this.boundUpdatePosition);
                document.removeEventListener("mouseup", this.boundReleaseWire);
                this.removeSelf()
            }
        }

        getCenterPos(element, change=0) {
            let rect = element.getBoundingClientRect();
            if (change == 1) return { x: rect.left + rect.width - 5, y: rect.top + rect.height / 2 - 4 };
            if (change == 2) return { x: rect.left, y: rect.top + rect.height / 2 };
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        updatePosition(event) {
            if (this.startElement) {
                this.startPos = this.getCenterPos(this.startElement, 1); // 🔥 Обновляем стартовую позицию
            }
            if (!this.endElement) {
                this.endPos = { x: event.clientX, y: event.clientY };
            } else {
                this.endPos = this.getCenterPos(this.endElement, 2);
            }
            this.updatePath();
        }

        updatePath() {
            let { x: x1, y: y1 } = this.startPos;
            let { x: x2, y: y2 } = this.endPos;
            let ctrl1 = { x: x1 + 50, y: y1 };
            let ctrl2 = { x: x2 - 50, y: y2 };
            this.path.setAttribute("d", `M ${x1},${y1} C ${ctrl1.x},${ctrl1.y} ${ctrl2.x},${ctrl2.y} ${x2},${y2}`);
        }

        releaseWire() {
            document.removeEventListener("mousemove", this.boundUpdatePosition);
            document.removeEventListener("mouseup", this.boundReleaseWire);

            if (this.endElement || !this.startElement) {
                return; 
            }

            let targetElement = this.findNearestPort();
            if (targetElement) {
                this.endElement = targetElement;
                this.endPos = this.getCenterPos(targetElement);

                this.editNext();
                this.updatePosition()
            } else {
                this.removeSelf();
            }
        }

        editNext() {
            try {
                let equal_element = null
                dialogue_nodes.forEach((dia) => {
                    if (dia.getElement() == this.endElement && equal_element === null) equal_element = dia
                })
                if (this.startElement.dataset.next !== "null") {
                    dialogueWires.forEach((conn) => {
                        if (conn.startElement == this.startElement && conn.endElement !== this.endElement) conn.removeSelf()
                    })
                }
                this.startElement.dataset.next = equal_element.getData().id
            } catch {
                console.log("[ERROR] Error is not fatal, don`t deserving any attention~ ")
            }
        }

        removeSelf () {
            this.svg.remove();
            dialogueWires = dialogueWires.filter(wire => wire !== this);
        }

        findNearestPort() {
            let ports = Array.from(document.querySelectorAll(".dialogue"))
            let closestPort = null;
            let minDist = 90;

            ports.forEach(port => {
                let portPos = this.getCenterPos(port);
                let dist = Math.hypot(portPos.x - this.endPos.x, portPos.y - this.endPos.y);
                if (dist < minDist) {
                    closestPort = port;
                    minDist = dist;
                }
            });
            return closestPort;
        }
    }

    class WireI {
        constructor(startElement, endElement=null) {
            this.startElement = startElement;
            this.endElement = endElement;

            this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.svg.style.position = "fixed";
            this.svg.style.width = "100%";
            this.svg.style.height = "100%";
            this.svg.style.zIndex = "100";
            this.svg.style.top = "0"
            this.svg.style.pointerEvents = "none";
            this.svg.classList.add("Dsvg")
            document.body.appendChild(this.svg);

            this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            this.path.setAttribute("stroke", "#6b74f3"); 
            this.path.setAttribute("stroke-width", "2");
            this.path.setAttribute("fill", "none");
            this.svg.appendChild(this.path);

            this.startPos = this.getCenterPos(this.startElement, 1)
            this.endPos = endElement == null ? { ...this.startPos } : this.getCenterPos(this.endElement, 2)
            
            this.boundUpdatePosition = this.updatePosition.bind(this);
            this.boundReleaseWire = this.releaseWire.bind(this);

            if (endElement == null) {
                document.addEventListener("mousemove", this.boundUpdatePosition);
                document.addEventListener("mouseup", this.boundReleaseWire);
            }

            // bugfix
            if (!startElement.parentElement.classList.contains("input-block")) {
                document.removeEventListener("mousemove", this.boundUpdatePosition);
                document.removeEventListener("mouseup", this.boundReleaseWire);
                this.removeSelf()
            }
        }

        getCenterPos(element, change=0) {
            let rect = element.getBoundingClientRect();
            if (change == 1) return { x: rect.left + rect.width - 5, y: rect.top + rect.height / 2 - 4 };
            if (change == 2) return { x: rect.left, y: rect.top + rect.height / 2 };
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        updatePosition(event) {
            if (this.startElement) {
                this.startPos = this.getCenterPos(this.startElement, 1); // 🔥 Обновляем стартовую позицию
            }
            if (!this.endElement) {
                this.endPos = { x: event.clientX, y: event.clientY };
            } else {
                this.endPos = this.getCenterPos(this.endElement, 2);
            }
            this.updatePath();
        }

        updatePath() {
            let { x: x1, y: y1 } = this.startPos;
            let { x: x2, y: y2 } = this.endPos;
            let ctrl1 = { x: x1 + 50, y: y1 };
            let ctrl2 = { x: x2 - 50, y: y2 };
            this.path.setAttribute("d", `M ${x1},${y1} C ${ctrl1.x},${ctrl1.y} ${ctrl2.x},${ctrl2.y} ${x2},${y2}`);
        }

        releaseWire() {
            document.removeEventListener("mousemove", this.boundUpdatePosition);
            document.removeEventListener("mouseup", this.boundReleaseWire);

            if (this.endElement || !this.startElement) {
                return; 
            }

            let targetElement = this.findNearestPort();
            if (targetElement) {
                this.endElement = targetElement;
                this.endPos = this.getCenterPos(targetElement);

                this.editIns();
                this.updatePosition();
            } else {
                Alert("Input block cant be connected with this. Try connect it with operator", "warning")
                this.removeSelf();
            }
        }

        editIns() {
            operator_nodes.forEach(op => {
                if (op.getElement() == this.endElement) { if (op.connectedTo.find(index => index == this.startElement.parentElement.dataset.index) == null) op.connectedTo.push(this.startElement.parentElement.dataset.index); return } 
            })
        }

        removeSelf () {
            this.svg.remove();
            dialogueWires = dialogueWires.filter(wire => wire !== this);
        }

        findNearestPort() {
            let ports = Array.from(document.querySelectorAll(".operator"))
            let closestPort = null;
            let minDist = 90;

            ports.forEach(port => {
                let portPos = this.getCenterPos(port);
                let dist = Math.hypot(portPos.x - this.endPos.x, portPos.y - this.endPos.y);
                if (dist < minDist) {
                    closestPort = port;
                    minDist = dist;
                }
            });
            return closestPort;
        }
    }

    function updatePageSize() {
        let maxX = 0, maxY = 0;

        document.querySelectorAll(".scenario-block").forEach(block => {
            const rect = block.getBoundingClientRect();
            maxX = Math.max(maxX, block.offsetLeft);
            maxY = Math.max(maxY, block.offsetTop + rect.height);
        });

        MW.style.width = `${maxX + 180}px`; 
        MW.style.height = `${maxY}px`;
        const rect = document.querySelector("#targetElement").getBoundingClientRect()
        maxX = Math.max(document.documentElement.clientWidth, maxX)
        maxY = Math.max(document.documentElement.clientHeight, maxY)
        document.querySelector("#targetElement").style.width = `${maxX + 180}px`
        document.querySelector("#targetElement").style.height = `${maxY}px`
    }

    function updateDialogueWindowSize() {
        let maxX = 0, maxY = 0;

        document.querySelectorAll(".dialogue").forEach(block => {
            const rect = block.getBoundingClientRect();
            maxX = Math.max(maxX, block.offsetLeft);
            maxY = Math.max(maxY, block.offsetTop + rect.height);
        });

        DW.style.width = `${maxX + 180}px`; 
        DW.style.height = `${maxY}px`;
        maxX = Math.max(document.documentElement.clientWidth, maxX)
        maxY = Math.max(document.documentElement.clientHeight, maxY)
        document.querySelector("#dialogueEditor").style.width = `${maxX + 180}px`
        document.querySelector("#dialogueEditor").style.height = `${maxY}px`
    }

    // проводки сценарных блоков
    document.addEventListener("scroll", (event) => {
        updatePageSize()
        wireConnections.forEach((wire) => {
            wire.updatePosition(event);
        })
    })

    // проводки диалоговых блоков
    document.querySelector("#dialogueEditor").addEventListener("scroll", (event) => {
         dialogueWires.forEach(wire => {
            wire.updatePosition(event);
        })
    })

    function showMenu(options, event, callback) {
        const menu = document.getElementById("menu");
        menu.innerHTML = ""; // Очищаем меню

        options.forEach(option => {
            const item = document.createElement("div");
            item.textContent = option;
            item.onclick = () => {
                menu.style.display = "none";
                callback(option);
            };
            menu.appendChild(item);
        });

        menu.style.left = event.pageX + "px";
        menu.style.top = event.pageY + "px";
        menu.style.display = "block";

        document.addEventListener("click", () => {
            menu.style.display = "none";
        }, { once: true });
    }

    function loadDialogue(quest_data) {
        current_quest = quest_data.index
        DW.innerHTML = '<div class="freezed"><div class="setupable"></div></div>'; 
        document.querySelector(".setupable").addEventListener("contextmenu", (event) => { event.preventDefault(); event.stopPropagation() })
        global_data[current_quest]["dialogues"].forEach((dl) => {
            const dia = new DialogueBlock(dl)
            dialogue_nodes.push(dia)
        })
        scenario_blocks[current_quest].getData().inputs.forEach((input, index) => {
            const inp = new InputBlock({"name": input.name, "index": index})
            input_nodes.push(inp)
        })
        global_data[current_quest]["operators"].forEach((op) => {
            const operator= new OperatorBlock(op)
            operator_nodes.push(operator)
        })
    }

    function openEditor(quest_data=null) {
        document.body.style.overflow = "hidden";
        if (document.querySelector('.open') == null) {
            document.querySelector("#close-btn").classList.remove("hidden")
            document.getElementById('dialogueEditor').classList.add('open');
            quest_data? loadDialogue(quest_data) : console.log("quest data is null")
        } else {console.log("blocked")}
        updateDialogueWindowSize();
        document.querySelector('#dialogueEditor').addEventListener("mousemove", () => { updateDialogueWindowSize() })
        const editor = document.getElementById("dialogueEditor")
        const onTransitionEnd = () => {
            spawnDialogueWires();
            respawnSymbiotes();
            editor.removeEventListener("transitionend", onTransitionEnd);
        };

        editor.addEventListener("transitionend", onTransitionEnd);
    }

    function closeEditor() {
        document.body.style.overflow = "scroll";
        global_data[current_quest]["operators"] = []; 
        global_data[current_quest]["dialogues"] = []; // очищаем и снова заполняем
        dialogue_nodes.forEach((dl) => {
            global_data[current_quest]["dialogues"][dialogue_nodes.indexOf(dl)] = dl.getData();
        })
        operator_nodes.forEach((op) => {
            global_data[current_quest]["operators"][operator_nodes.indexOf(op)] = op.getData();
        })
        document.getElementById('dialogueEditor').classList.remove('open');
        document.querySelector("#close-btn").classList.add("hidden")
        updatePageSize();
        dialogue_nodes = []
        input_nodes = []
        operator_nodes = []
        document.querySelector('#dialogueEditor').removeEventListener("mousemove", () => { updateDialogueWindowSize() })
        document.querySelectorAll('.Dsvg').forEach(svg => svg.remove())
    }

    function newScenarioBlock(x=0, y=0) {
        const scenario = new ScenarioBlock({"name": `Quest_${document.querySelectorAll(".scenario-block").length}`, "inputs": [{"name": "new_input", "active": false}], "outputs": [{"name": "new_output", "next": null}], "pos": [x, y]}, document.querySelectorAll(".scenario-block").length);
        scenario_blocks[scenario.getData().index] = scenario
        global_data[scenario.getData().index] = scenario.getData()
    }

    function newDialogueBlock(x=0, y=0) {
        if (document.querySelector(".open") !== null) { 
            const new_dialogue = new DialogueBlock({"speaker": "NPC", "text": "Standart phrase", "id": `node-${dialogue_nodes.length}`, "choices": [], "pos": [x, y]}) 
            global_data[current_quest].dialogues.push(new_dialogue.getData())
            dialogue_nodes.push(new_dialogue)
        }
    }

    function newOperatorBlock(x=0, y=0) {
        if (document.querySelector(".open") !== null) { 
            const new_operator = new OperatorBlock({"pos": [x, y]}) 
            global_data[current_quest].operators.push(new_operator.getData())
            operator_nodes.push(new_operator)
        }
    }

    function scenarioContextMenu(event) {
        event.preventDefault();
        showMenu(["add scenario block", "save as file~"], event, (callback) => {
            if (callback == "add scenario block") newScenarioBlock(event.clientX, event.clientY)
            if (callback == "save as file~") saveJSON()
        }) 
    }

    function dialogueContextMenu(event) {
        event.preventDefault();
        showMenu(["add dialogue", "add operator"], event, (callback) => {
            if (callback == "add dialogue") newDialogueBlock(event.clientX, event.clientY) 
            else if (callback == "add operator") newOperatorBlock(event.clientX, event.clientY)
        }) 
    }

    window.onbeforeunload = function (event) {
        event.preventDefault(); // Официально требуется, но браузеры могут игнорировать
        event.returnValue = "Вы уверены, что хотите покинуть страницу?";
    };

    function saveJSON() {
        scenario_blocks.forEach((sc) => {
            const data = sc.getData()
            global_data[data.index] = data
        })
        const jsonData = global_data;
        const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: "application/json" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "data.json";
        link.click();
    }

    function spawnDialogueWires() {
        document.querySelectorAll(".Dsvg").forEach(svg => svg.remove())
        dialogueWires = []
        dialogue_nodes.forEach((dia) => {
            dia.getData().choices.forEach((output) => {
                if (output.next !== null) {
                    const currentBlock = dia.getElement();
                    const nextBlock = dialogue_nodes.find(d => d.id == output.next);

                    if (nextBlock) {
                        // Ищем конкретный порт внутри currentBlock, у которого data-next совпадает с output.next
                        const portElement = Array.from(currentBlock.querySelectorAll(".port"))
                            .find(port => port.querySelector(".choice-input").dataset.next === output.next);

                        if (portElement) {
                            const wire = new WireD(portElement, nextBlock.getElement() || null);                        
                            dialogueWires.push(wire);
                        }
                    }
                }
            })
        })
        operator_nodes.forEach((op) => {
            // op-next
            if (op.getData().next !== null) {
                const currentBlock = op.getElement();
                const nextBlock = dialogue_nodes.find(d => d.id == op.getData().next);

                if (nextBlock) {
                    const portElement = op.port

                    if (portElement) {
                        const wire = new WireO(portElement, nextBlock.getElement() || null);                        
                        dialogueWires.push(wire);
                    }
                }
            }
            // op-connected inputs
            op.connectedTo.forEach((index) => {
                const wire = new WireI(input_nodes[index].portDiv, op.getElement())
                dialogueWires.push(wire);
            })
        })
        dialogueWires.forEach(wire => wire.updatePosition())
    }

    function spawnWires() {
        document.querySelectorAll(".svg").forEach(svg => svg.remove())
        wireConnections = []
        scenario_blocks.forEach((sc) => {
            sc.getData().outputs.forEach((output) => {
                if (output.next !== null) {
                    const currentBlock = sc.getElement();
                    const nextBlock = scenario_blocks[output.next];

                    if (nextBlock) {
                        // Ищем конкретный порт внутри currentBlock, у которого data-next совпадает с output.next
                        const portElement = Array.from(currentBlock.querySelectorAll(".port"))
                            .find(port => port.querySelector(".output").dataset.next === output.next);

                        if (portElement) {
                            const wire = new Wire(portElement, nextBlock.getElement() || null);                        
                            wireConnections.push(wire);
                        }
                    }
                }
            });
        });
        wireConnections.forEach((wire) => { wire.updatePosition() })
    }

    function respawnSymbiotes() {
        document.querySelectorAll(".symbiote").forEach(sm => sm.remove())
        symbiotes = []
        dialogue_nodes.forEach(dia => {
            if (dia.getData().choices.length > 0) {
                dia.getData()["choices"].forEach((c, index) => {
                    const rs = c.next || "null"
                    if (rs.startsWith("out_")) { 
                        const out = scenario_blocks[current_quest].getData()["outputs"][rs.substring(4, 5)] || null
                        if (out) { 
                            const sm = new Symbiote(out, rs.substring(4, 5), dia.getElement().querySelectorAll(".port")[index]); 
                            symbiotes.push(sm) 
                        }                
                    }
                })
            }
        })
        symbiotes.forEach(sm => sm.updatePosition())
    }

    function chooseEnding(callback) {
        if (document.querySelector(".open") !== null) {
            const fillscreen = document.createElement("div");
            fillscreen.style.cssText = `
                background: rgba(0, 0, 0, 80%); display: flex;
                width: 100vw; height: 100vh; position: fixed;
                z-index: 99999; top: 0; left: 0; justify-content: space-around; align-items: center;
            `;
            fillscreen.id = "fsc";

            let line = `
                <div style="pointer-events: all; padding: 10px; background: white; width: 400px; height: 180px; display: flex;flex-direction: column;justify-content: center;align-items: center;gap: 20px;border-radius: 15px;">
                    <h2 style="font-family: monospace; font-size: 30px;">choose ending</h2>
                    <select id="window-select" style="max-width: 250px;"><option value="null">null</option>
            `;

            scenario_blocks[current_quest].getData()["outputs"].forEach((output, index) => {
                let text = output.name
                if (text.length > 27) { text = text.substring(0, 27) + "..." }
                line += `<option value="out_${index}">${text}</option>`;
            });

            line += `</select><button id="done-button" style="margin-top: 5px;background: #e6e6e6;padding: 5px;border-radius: 5px;">done</button></div>`;
            fillscreen.innerHTML = line;
            document.body.appendChild(fillscreen);

            document.querySelector("#done-button").addEventListener("click", () => {
                windowButtonFunction(callback);
            });
        }
    }

    function windowButtonFunction(callback) {
        const choice = document.querySelector("#window-select").value;
        document.querySelector("#fsc").remove();
        if (typeof callback === "function") {
            callback(choice);
        }
    }


    function loadJSON() {
        MW.innerHTML = ""
        const file = document.getElementById("fileInput").files[0]; 
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const jsonData = JSON.parse(event.target.result);
            global_data = jsonData

            global_data.forEach((data, index) => {
                const scenario = new ScenarioBlock(data, index)
                scenario_blocks[scenario.getData().index] = scenario
            })

            // проводочки!
            spawnWires()
        };
        reader.readAsText(file);
    }

    function Import() {
        if (document.querySelector('.open') != null) closeEditor();

        const fileInput = document.getElementById("fileInput2");
        const file = fileInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const importedData = JSON.parse(event.target.result);

            // Определяем последний занятый индекс
            let lastIndex = global_data.length;

            // Шаг 1: Обновляем `next` на новые свободные индексы
            importedData.forEach((data, index) => {
                const newIndex = lastIndex + index; // Обновляем индекс для импорта

                // Обновляем ссылки `next`
                data.outputs?.forEach(output => {
                    if (output.next) {
                        output.next = parseInt(output.next) + lastIndex; // Новое значение
                    }
                });

                // Добавляем квест в массив
                global_data.push(data);

                // Создаем объект ScenarioBlock
                const scenario = new ScenarioBlock(data, newIndex);
                scenario_blocks[newIndex] = scenario;

                // Добавляем класс `imported` в DOM
                scenario.getElement().classList.add("imported");
            });

            spawnWires(); // Перерисовка связей
            fileInput.value = ""; // Сброс input, чтобы можно было повторно загрузить тот же файл
        };

        reader.readAsText(file);
    }


    function Alert(text, alert_type = "usual") {
        const box = document.getElementById('alert-box');
        const textElem = document.getElementById('alert-text');
        const bar = document.getElementById('progress-bar');
        const duration = Math.max(20 * text.length, 1500);

        // Сброс
        if (timer) clearTimeout(timer);
        bar.style.transition = 'none';
        bar.style.width = '100%';

        box.className = `alert ${alert_type}`;
        textElem.textContent = text;
        box.style.display = 'block';

        void box.offsetWidth;
        box.classList.add('show');

        // Запускаем анимацию прогрессбара
        setTimeout(() => {
        bar.style.transition = `width ${duration}ms linear`;
        bar.style.width = '0%';
        }, 10);

        timer = setTimeout(() => {
        box.classList.remove('show');
        setTimeout(() => box.style.display = 'none', 300);
        }, duration);
    }
</script>
</body>
</html>